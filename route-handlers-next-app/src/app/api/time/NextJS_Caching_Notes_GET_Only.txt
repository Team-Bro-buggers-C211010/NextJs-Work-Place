=======================================================
ğŸ“˜ Notes on Caching in Next.js (App Router) â€“ GET Method Only
=======================================================

Caching is essential for performance optimization, reducing server load, and improving response times. In Next.js (App Router), caching is **only applicable to GET requests** in Route Handlers.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Why Only GET?

HTTP caching mechanisms are built for safe, idempotent operations.  
GET is the only HTTP method that should return the same response without changing server state â€” making it suitable for caching.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Types of Caching in Next.js

âœ… 1. **Full HTTP Response Caching**  
âœ… 2. **Custom Cache-Control Headers**  
âœ… 3. **Revalidation with fetch**  
âœ… 4. **Static and Dynamic Caching (Edge)**

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Setting Cache Headers in GET Route

```ts
import { NextResponse } from 'next/server';

export async function GET() {
  const res = NextResponse.json({ message: 'Cached Response' });

  // Public cache, valid for 10 minutes
  res.headers.set('Cache-Control', 'public, max-age=600');

  return res;
}
```

ğŸ“Œ Cache Directives:
- `max-age=600` â†’ cache for 10 minutes
- `no-store` â†’ disables caching
- `s-maxage` â†’ used by CDNs (like Vercel)
- `stale-while-revalidate` â†’ serves stale while revalidating in background

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Revalidation using fetch (Recommended)

Next.js supports fetch caching directly via options:

```ts
export async function GET() {
  const data = await fetch('https://api.example.com/posts', {
    next: { revalidate: 60 } // Revalidate every 60 seconds
  });

  const json = await data.json();
  return NextResponse.json(json);
}
```

âœ… `next: { revalidate: 0 }` â†’ disables caching (on-demand revalidation)  
âœ… `next: { revalidate: 3600 }` â†’ cache for 1 hour

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¹ Skipping Cache Completely

```ts
const res = await fetch('https://api.example.com/user', {
  cache: 'no-store'
});
```

ğŸ›‘ Avoid this in POST, PUT, DELETE â€” caching is only relevant in GET routes.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ” Good Use Cases for Caching in GET

- Public APIs (news, blogs, leaderboard, etc.)
- Product listings, static data
- Expensive or slow-to-generate queries
- Pages served through CDN (static props)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“š Summary

âœ… Cache is **only used in GET** route handlers  
âœ… Use `Cache-Control` headers or `next.revalidate` in fetch  
âœ… Avoid using caching for POST, PATCH, DELETE  
âœ… Use `no-store` when dealing with sensitive/real-time data

ğŸ¯ Smart caching reduces cost, improves user experience, and keeps your Next.js API lightning fast!
